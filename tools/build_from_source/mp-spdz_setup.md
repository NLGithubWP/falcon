## SPDZ: providing additive secret sharing based MPC

MP = multi-party. SPDZ is a secure multi-party computation (MPC) protocol.

**the primary aim of the MP-SPDZ repo is to "run the same computation in various protocols in order to compare the performance"**

The MP-SPDZ repo (and parent repos like https://github.com/data61/MP-SPDZ) cutomized by wyc contains several dependent repos as git-submodules:
```bash
[submodule "SimpleOT"]
	path = SimpleOT
	url = git@github.com:mkskeller/SimpleOT.git
[submodule "mpir"]
	path = mpir
	url = git://github.com/wbhart/mpir.git
[submodule "Programs/Circuits"]
	path = Programs/Circuits
	url = git@github.com:mkskeller/bristol-fashion.git
```

### Note on SimpleOT

OT = oblivious transfer "oblivious transfer (OT) protocol is a type of protocol in which a sender transfers one of potentially many pieces of information to a receiver, but remains oblivious as to what piece (if any) has been transferred."

the OT  oblivious transfer, which is implemented as OT extension based on https://github.com/mkskeller/SimpleOT.

the `semi-party.x` program is generated by OT-based protocol for **semi-dishonest majority**


### Note on Mpir

MPIR is a fork of the GNU Multi Precision library (GMP)

MPIR is a library for arbitrary precision arithmetic, operating on signed
integers, rational numbers, and floating point numbers.


### MP-SPDZ Requirements
 - GCC 5 or later (tested with up to 9) or LLVM/clang 5 or later (tested with up to 9). We recommend clang because it performs better.
 - MPIR library, compiled with C++ support (use flag `--enable-cxx` when running configure). You can use `make -j8 tldr` to install it locally.
 - libsodium library, tested against 1.0.16
 - OpenSSL, tested against and 1.0.2 and 1.1.0
 - Boost.Asio with SSL support (`libboost-dev` on Ubuntu), tested against 1.65
 - Boost.Thread for BMR (`libboost-thread-dev` on Ubuntu), tested against 1.65
 - 64-bit CPU
 - Python 3.5 or later
 - NTL library for homomorphic encryption (optional; tested with NTL 10.5)
 - If using macOS, Sierra or later

(from MP-SPDZ `README.md`)

the above roughly translates into:
```bash
apt-get install automake build-essential git libboost-dev libboost-thread-dev libsodium-dev libssl-dev libtool m4 python3 texinfo yasm
```


## Steps to run spdz programs

The SPDZ protocol uses preprocessing, that is, in a first (sometimes called **offline**) phase correlated randomness is generated independent of the actual inputs of the computation. Only the **second ("online")** phase combines this randomness with the actual inputs in order to produce the desired results.


### To setup for benchmarking the online phase

The `setup-online.sh` script must also be run from `./` to create the relevant data.

Parameters can be customised by running

```bash
Scripts/setup-online.sh <nparties> <nbitsp> <nbits2>
```

This sets up parameters for the online phase for 3 parties with a 128-bit **prime field** and 128-bit **binary field**, and creates fake offline data (multiplication triples etc.) for these parameters.

**NOTE: the `setup-online.sh` is done by `fast-make.sh`**


### To setup encryption channels

All protocols require encrypted channels. Therefore, an eavesdropper on the network could learn all information.

MP-SPDZ uses OpenSSL for secure channels. You can generate the necessary certificates and keys as follows:

`Scripts/setup-ssl.sh [<number of parties>]`

The programs expect the keys and certificates to be in
`Player-Data/P<i>.key` and `Player-Data/P<i>.pem`, respectively, and
the certificates to have the common name `P<i>` for player
`<i>`. Furthermore, the relevant root certificates have to be in
`Player-Data` such that OpenSSL can find them (run `c_rehash
Player-Data`). The script above takes care of all this by generating
self-signed certificates. Therefore, if you are running the programs
on different hosts you will need to copy the certificate files.

For Falcon setup, use `setup-clients.sh` instead of `setup-ssl.sh`:

```bash
Scripts/setup-clients.sh 3

# setup-ssl and setup-clients scripts will run the following:
openssl req -newkey rsa -nodes -x509 -out Player-Data/C$i.pem -keyout Player-Data/C$i.key -subj "/CN=C$i"
```


### Compile high-level program

To compile the mpc-program written, run the `compile.py`.

For example, the mpc-program is in `Programs/Source/logistic_regression.mpc`:

```bash
./compile.py Programs/Source/logistic_regression.mpc
```

This creates the bytecode and schedule files in `Programs/Bytecode/` and `Programs/Schedules/`.


### Falcon Logistic Regression MPC

See `third_party/MP-SPDZ/Programs/Source/` for some example MPC programs

**from `third_party/MP-SPDZ/Programs/Source/logistic_regression.mpc`**:

Provide logistic function MPC computation for falcon project

Specifically, this program does in three steps:
(1) First, keep waiting enough clients (equals to party_num) connected to this program.
(2) Second, once enough clients connected, read the input values and compute the logistic function.
(3) Third, return the gfp results (in the secret shared form) to the clients.

Need to set the following parameters before running:
(1) ARRAY_SIZE: equals to batch size in the falcon project;
(2) MAX_NUM_CLIENTS: equals to party number in the falcon project;
(3) FIXED_F: must be consistent with the SPDZ_PRECISION in the falcon project;
(4) PORT_NUM: equals to the SPDZ_PORT_BASE in the falcon project;

Note each client connects in a single thread and so is potentially blocked.
Each round / game will reset and so this runs indefinitiely.

**Change batch size by changing the `ARRAY_SIZE` value**, and then **recompile the mpc file** (see the README in `src/executor/algorithm/vertical/linear_model/README.md`)

**NOTE: `fast-make.sh` already carries out the compilation for `logistic_regression.mpc` file, so recompiling the entire MP-SPDZ with `mp-spdz_setup.sh` does this step already**

### Run `semi-party.x` on one machine

To run the `semi-party.x` with three parties on one machine, run:

`./semi-party.x -F -N 3 -p 0 -I logistic_regression`

`./semi-party.x -F -N 3 -p 1 -I logistic_regression` (in a separate terminal)

`./semi-party.x -F -N 3 -p 2 -I logistic_regression` (in a separate terminal)

Using `-I` activates interactive mode, which means that inputs are
solicitated from standard input, and outputs are given to any
party. Omitting `-I` leads to inputs being read from
`Player-Data/Input-P<party number>-0` in text format.


### OpenSSL setup

for issue of "Can't load ./.rnd into RNG" see https://github.com/openssl/openssl/issues/7754

you have to configure `/usr/local/ssl/openssl.cnf`:
> if you have RANDFILE=... configuration lines in your openssl.cnf than you can safely remove them

